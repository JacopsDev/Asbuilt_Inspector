# -*- coding: utf-8 -*-
"""
/***************************************************************************
 AsbuiltInspectorDialog
                                 A QGIS plugin
 an efficient tool for Unifiber
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-04-30
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Jacops
        email                : toon.vandevoorde@jacops.be
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import base64
import os
import tempfile
from collections import Counter, defaultdict
import re
from io import BytesIO

from PyQt5.QtCore import Qt, QSizeF, QByteArray, QBuffer, QRect
from PyQt5.QtGui import QColor, QTextDocument, QPainter, QImage, QIcon, QPixmap
from PyQt5.QtWidgets import QDialog, QVBoxLayout, QTextBrowser, QPushButton, QApplication
from qgis._core import QgsGeometry, QgsProject, QgsVectorLayer, QgsWkbTypes, QgsFeatureRequest, QgsHtmlAnnotation, \
    QgsPointXY, QgsSymbol, QgsFillSymbol, QgsMapRendererCustomPainterJob, QgsMapSettings
from qgis._gui import QgsMapToolEmitPoint, QgsRubberBand, QgsMapCanvasAnnotationItem
from qgis.gui import QgsMapToolIdentifyFeature
from qgis.PyQt import uic
from qgis.PyQt import QtWidgets

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
# FORM_CLASS, _ = uic.loadUiType(os.path.join(
#     os.path.dirname(__file__), 'LayerInspector_dialog_base.ui'))
# class AsbuiltInspectorDialog(QtWidgets.QDialog, FORM_CLASS):


class AsbuiltInspectorDialog(QgsMapToolEmitPoint):
    def __init__(self, iface, parent=None):
        super().__init__(iface.mapCanvas())
        self.parent = parent
        self.canvas = iface.mapCanvas()
        self.iface = iface
        self.browser = None
        self.html_img_tag = None

        self.canvas = iface.mapCanvas()
        self.rubberBand = QgsRubberBand(self.canvas, QgsWkbTypes.PolygonGeometry)
        self.rubberBand.setColor(QColor(255, 0, 0, 100))
        self.rubberBand.setWidth(2)
        self.points = []

        self.found = []



    def canvasPressEvent(self, event):
        if event.button() == Qt.LeftButton:
            point = self.canvas.getCoordinateTransform().toMapCoordinates(event.pos())
            self.points.append(point)
            self.rubberBand.addPoint(point, True)
        elif event.button() == Qt.RightButton:
            self.finish()

    def finish(self):
        if len(self.points) < 3:
            self.reset()
            return

        self.rubberBand.addPoint(self.points[0], True)
        # // add first point in self.points as star
        # // set full geom to use points arr
        self.rubberBand.setToGeometry(QgsGeometry.fromPolygonXY([self.points]))
        polygon_geom = QgsGeometry.fromPolygonXY([self.points])

        # Identify features
        found = self.identifyFeatures(polygon_geom)
        self.show_feature_dialog(found, polygon_geom)


        self.reset()
        return found

    def identifyFeatures(self, geometry):
        found_features = []
        for layer in QgsProject.instance().mapLayers().values():
            if not isinstance(layer, QgsVectorLayer):
                continue
            if layer.geometryType() == QgsWkbTypes.NoGeometry:
                continue

            request = QgsFeatureRequest().setFilterRect(geometry.boundingBox())
            for feature in layer.getFeatures(request):
                if geometry.intersects(feature.geometry()):
                    found_features.append((layer.name(), feature.id(), feature, layer))
        return found_features

    def save_text_browser_as_png(self):
        # Grab the widget as a pixmap
        pixmap = self.browser.grab()
        # Optional: Save to a file
        temp_file = tempfile.NamedTemporaryFile(suffix=".png", delete=False)
        pixmap.save(temp_file.name, "PNG")

        print(f"Saved to: {temp_file.name}")

        clipboard = QApplication.clipboard()
        clipboard.setPixmap(pixmap)

    # def drawpng(self, geom):
    #
    #     bbox = geom.boundingBox()
    #     rect = QRect(int(bbox.xMinimum()), int(bbox.yMinimum()),
    #                  int(bbox.width()), int(bbox.height()))
    #
    #     # Now crop the canvas pixmap
    #     canvas_pixmap = self.iface.mapCanvas().grab()
    #     cropped_pixmap = canvas_pixmap.copy(rect)
    #
    #     return self.setQbyteArray(cropped_pixmap)
    #
    #
    # def setQbyteArray(self, img):
    #     byte_array = QByteArray()
    #     buffer = QBuffer(byte_array)
    #     buffer.open(QBuffer.WriteOnly)
    #     img.save(buffer, "PNG")
    #     buffer.close()
    #
    #     base64_data= byte_array.toBase64().data().decode()
    #     html_img_tag = f"<img src='data:image/png;base64,{base64_data}' style='max-width:100%; border: 1px solid #ccc;' />"
    #     return html_img_tag



    def reset(self):
        self.points = []
        self.rubberBand.reset(QgsWkbTypes.PolygonGeometry)

    def get_base_table_name(layer):
        uri = layer.dataProvider().dataSourceUri()
        match = re.search(r'table="(?:[^"]+\.)?([^"]+)"', uri)
        if match:
            return match.group(1).lower()
        return None

    def copy_text(txt):
        QApplication.clipboard().setText(txt)

    def show_feature_dialog(self, found, geom):
        if not found:
            return

        dialog = QDialog(self.parent)
        dialog.setWindowTitle("SABINE")
        dialog.resize(300, 550)  # Optional initial size
        dialog.setSizeGripEnabled(True)  # Allows user resizing
        layout = QVBoxLayout(dialog)

        self.browser = QTextBrowser(dialog)
        self.browser.setTextInteractionFlags(Qt.TextSelectableByKeyboard | Qt.TextSelectableByMouse)
        layout.addWidget(self.browser)

        self.copy_button = QPushButton("Copy Text", dialog)

        plugin_dir = os.path.dirname(os.path.abspath(__file__))
        icon_pathp = os.path.join(plugin_dir,
                                 'paste.png')

        plugin_dir = os.path.dirname(os.path.abspath(__file__))
        icon_path = os.path.join(plugin_dir,
                                 'water-color.png')
        icon = QIcon(icon_path)
        dialog.setWindowIcon(icon)
        iconc = QIcon(icon_pathp)
        self.copy_button.setIcon(iconc)

        self.icon_inactive = QIcon(icon_path)
        layout.addWidget(self.copy_button)

        def get_base_table_name(layer):
            uri = layer.dataProvider().dataSourceUri()
            match = re.search(r'table="[^"]+"\."([^"]+)"', uri)
            if match:
                return match.group(1).lower()
            return "other"

        grouped = defaultdict(lambda: {"features": [], "layers": set()})
        for layer_name, fid, feature, layer in found:
            db_table = get_base_table_name(layer)
            mapping = {
                "accesspoints": "accesspoint",
                "crossings": "crossing",
                "trenching": "trenching"
            }
            group_key = mapping.get(db_table, "other")

            grouped[group_key]["features"].append((feature, layer))
            grouped[group_key]["layers"].add(layer_name)

        html = """
        <h2 style="color:#2c3e50; margin-bottom: 10px;">Selected Features through all layers </h2>
        <ul style="padding-left: 20px;">
        """
        plain_text = "Selected Features\n"

        for group_name, data in grouped.items():
            features = data["features"]
            html += f"<li><span style='font-weight:bold; color:#2980b9;'>{group_name}</span> – {len(features)} features"
            html += "<div style='margin-top: 5px;margin-bottom:5px; margin-left: 10px;'>"
            plain_text += f"{group_name.capitalize()} – {len(features)} features\n"

            if group_name == "crossing":
                crossing_field_prefixes = ["db24", "db3_14", "db5_14", "db7_14", "db3_20", "db14", "wachtbuis", "pe",
                                           "db7_gr", "d7_or"]

                field_counter = {}  # Total installed length
                field_feature_count = {}  # How many features contribute to this field
                total_length = 0

                for feature, layer in features:
                    geom = feature.geometry()
                    if geom and geom.isGeosValid():
                        geom_length = geom.length()
                        total_length += geom_length

                        for field in layer.fields():
                            fname = field.name()
                            if any(fname.startswith(prefix) for prefix in crossing_field_prefixes):
                                val = feature[fname]
                                if val is not None and str(val).replace(".", "", 1).isdigit():
                                    val_float = float(val)
                                    total_field_length = val_float * geom_length
                                    # Accumulate total installed length
                                    field_counter[fname] = field_counter.get(fname, 0) + total_field_length
                                    # Count how many features had this field > 0
                                    if val_float > 0:
                                        field_feature_count[fname] = field_feature_count.get(fname, 0) + 1


                # Per-field breakdown
                html += "<div style='margin-left:10px;'><ul style='margin-top: 4px;'>"
                plain_text += "Field totals:\n"

                for field_name in sorted(field_counter):
                    total_installed = round(field_counter[field_name], 2)
                    count = field_feature_count.get(field_name, 0)
                    if count != 0:
                        html += f"<li><b>{field_name}</b><span style='color:#2596be'> ({count}x)</span> <span style='color:#27ae60;'> {total_installed}m</span></li>"
                        plain_text += f"{field_name}: {count}× totaling {total_installed} m\n"
                html += "</ul><br>"



            elif group_name == "trenching":

                trench_field_prefixes = ["db24", "db3_14", "db5_14", "db7_14", "db3_20", "db14", "wachtbuis", "pe",

                                         "db7_gr", "d7_or", "srv", "hdpe"]

                field_counter = {}  # Total installed length per field
                field_feature_count = {}  # Number of features contributing per field
                total_length = 0  # Total geometry length of trenching
                for feature, layer in features:
                    geom = feature.geometry()
                    if geom and geom.isGeosValid():
                        geom_length = geom.length()
                        total_length += geom_length
                        for field in layer.fields():
                            fname = field.name()
                            if any(fname.startswith(prefix) for prefix in trench_field_prefixes):
                                val = feature[fname]
                                if val is not None and str(val).replace(".", "", 1).isdigit():
                                    val_float = float(val)
                                    total_field_length = val_float * geom_length
                                    field_counter[fname] = field_counter.get(fname, 0) + total_field_length
                                    if val_float > 0:
                                        field_feature_count[fname] = field_feature_count.get(fname, 0) + 1

                plain_text += f"Total Length: {round(total_length, 2)} m\n"

                html += "<div style='margin-left:10px;'><ul style='margin-top: 4px;'>"
                plain_text += "Field totals:\n"

                for field_name in sorted(field_counter):
                    total_installed = round(field_counter[field_name], 2)
                    count = field_feature_count.get(field_name, 0)
                    if count != 0:
                        html += f"<li><b>{field_name}</b><span style='color:#2596be;'> ({count}x)</span> <span style='color:#27ae60;'> {total_installed}m</span></li>"
                        plain_text += f"{field_name}: {count}× totaling {total_installed} m\n"
                html += "</ul><br>"

            elif group_name == "accesspoint":
                materiaal_counter = Counter()

                for feature, layer in features:
                    for field in layer.fields():
                        fname = field.name().lower()
                        if "materiaal" in fname:  # Adjust based on actual field names
                            val = feature[fname]
                            if val:
                                materiaal_counter[str(val)] += 1

                if materiaal_counter:
                    html += "<div style='margin-left:10px;'><b>Les matériaux:</b><ul style='margin-bottom:10px;'>"
                    for mat_val, count in materiaal_counter.items():
                        html += f"<li><b>{mat_val}</b> (<span style='color:#27ae60;'>×{count}</span>)</li>"
                        plain_text += f"{mat_val} (×{count})\n"
                    html += "</ul></div>"
        self.browser.setHtml(html)
        self.save_text_browser_as_png()
        self.copy_button.clicked.connect(self.copy_text)




        dialog.setLayout(layout)
        dialog.exec_()


