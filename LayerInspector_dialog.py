# -*- coding: utf-8 -*-
"""
/***************************************************************************
 AsbuiltInspectorDialog
                                 A QGIS plugin
 an efficient tool for Unifiber
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-04-30
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Jacops
        email                : toon.vandevoorde@jacops.be
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import base64
import os
import tempfile
from collections import Counter, defaultdict
import re
from io import BytesIO

import re
from collections import defaultdict, Counter

from PyQt5.QtCore import Qt, QSizeF, QByteArray, QBuffer, QRect
from PyQt5.QtGui import QColor, QTextDocument, QPainter, QImage, QIcon, QPixmap
from PyQt5.QtWidgets import QDialog, QVBoxLayout, QTextBrowser, QPushButton, QApplication, QSizePolicy
from qgis._core import QgsGeometry, QgsProject, QgsVectorLayer, QgsWkbTypes, QgsFeatureRequest, QgsHtmlAnnotation, \
    QgsPointXY, QgsSymbol, QgsFillSymbol, QgsMapRendererCustomPainterJob, QgsMapSettings, Qgis
from qgis._gui import QgsMapToolEmitPoint, QgsRubberBand, QgsMapCanvasAnnotationItem
from qgis.gui import QgsMapToolIdentifyFeature
from qgis.PyQt import uic
from qgis.PyQt import QtWidgets

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
# FORM_CLASS, _ = uic.loadUiType(os.path.join(
#     os.path.dirname(__file__), 'LayerInspector_dialog_base.ui'))
# class AsbuiltInspectorDialog(QtWidgets.QDialog, FORM_CLASS):

class FeatureSummarizer:
    CROSSING_PREFIXES = ["db24", "db3_14", "db5_14", "db7_14", "db3_20", "db14", "wachtbuis", "pe", "db7_gr", "d7_or"]
    TRENCHING_PREFIXES = ["db24", "db3_14", "db5_14", "db7_14", "db3_20", "db14", "wachtbuis", "pe", "db7_gr", "db7_or", "srv", "hdpe", "db6_magenta"]

    TYPE_MAPPING = {
        "accesspoints": "accesspoint",
        "crossing": "crossing",
        "trenching": "trenching",
    }

    @staticmethod
    def parse_db_and_table(layer):
        uri = layer.dataProvider().dataSourceUri()
        db_match = re.search(r"dbname='([^']+)'", uri)
        dbname = db_match.group(1).lower() if db_match else "other"
        table_match = (
            re.search(r'table="[^"]+"\."([^"]+)"', uri) or
            re.search(r'table="([^"]+)"', uri) or
            re.search(r'table=([^ ]+)', uri)
        )
        table_name = table_match.group(1).lower() if table_match else "other"
        return dbname, table_name

    @classmethod
    def determine_group_key(cls, feature, layer):
        dbname, table_name = cls.parse_db_and_table(layer)
        project_val = (str(feature["project"]).lower() if "project" in feature.fields().names() else "")
        if "wyre" in project_val:
            db_group = "wyre"
        elif "proximus" in project_val:
            db_group = "proximus"
        elif "fiberklaar" in project_val:
            db_group = "fiberklaar"
        else:
            db_group = "other"
        type_key = cls.TYPE_MAPPING.get(table_name, "other")
        return f"{db_group}_{type_key}"

    @classmethod
    def accumulate_length(cls, features, prefixes):
        field_total = {}
        feature_count = {}
        total_len = 0
        for feat, lyr in features:
            geom = feat.geometry()
            if not geom or not geom.isGeosValid():
                continue
            g_len = geom.length()
            total_len += g_len
            for fld in lyr.fields():
                fname = fld.name()
                if any(fname.startswith(p) for p in prefixes):
                    val = feat[fname]
                    if val is None or not str(val).replace(".", "", 1).isdigit():
                        continue
                    val_f = float(val)
                    field_total[fname] = field_total.get(fname, 0) + val_f * g_len
                    if val_f > 0:
                        feature_count[fname] = feature_count.get(fname, 0) + 1
        return field_total, feature_count, total_len

    @staticmethod
    def render_length_summary(field_total, feature_count, header=""):
        text = ""
        html = "<div style='margin-left:10px;'><ul style='margin-top:4px;'>"
        for fname in sorted(field_total):
            installed = round(field_total[fname], 2)
            cnt = feature_count.get(fname, 0)
            if cnt == 0:
                continue  # Skip if the count is 0
            html += (
                f"<li><b>{fname}</b>"
                f"<span style='color:#2596be'> ({cnt}x)</span> "
                f"<span style='color:#27ae60;'> ➔  {installed}m</span></li>"
            )
            text += f"{fname}: (x{cnt}) ➔ {installed} m\n"
        html += "</ul><br>"
        return html, text

    @classmethod
    def summarize_crossings(cls, features, group_name):
        field_counter, feature_counter, length = cls.accumulate_length(features, cls.CROSSING_PREFIXES)
        header = f"{group_name} - Total Length: {round(length, 2)} m\n"
        return cls.render_length_summary(field_counter, feature_counter, header=header)

    @classmethod
    def summarize_trenching(cls, features, group_name):
        field_counter, feature_counter, length = cls.accumulate_length(features, cls.TRENCHING_PREFIXES)
        header = f"{group_name} - Total Length: {round(length, 2)} m\n"
        return cls.render_length_summary(field_counter, feature_counter, header=header)

    @staticmethod
    def summarize_accesspoints(features):
        materiaal_counter = Counter()
        for feat, lyr in features:
            for fld in lyr.fields():
                if "materiaal" in fld.name().lower():
                    val = feat[fld.name()]
                    if val:
                        materiaal_counter[str(val)] += 1
        html = "<div style='margin-left:10px;'></b><ul style='margin-bottom:10px;'>"
        text = ""
        for mat, cnt in materiaal_counter.items():
            html += f"<li><b>{mat}</b> (<span style='color:#27ae60;'>×{cnt}</span>)</li>"
            text += f"{mat} (×{cnt})\n"
        html += "</ul></div>"
        return html, text

    @classmethod
    def generate_summary(cls, found):
        grouped_by_db = defaultdict(lambda: defaultdict(list))

        for layer_name, fid, feature, layer in found:
            key = cls.determine_group_key(feature, layer)
            db_group, type_key = key.split("_", 1)
            grouped_by_db[db_group][type_key].append((feature, layer))

        html = ""
        text = ""

        for db_group, type_dict in grouped_by_db.items():
            if db_group.lower() == "wyre":
                header_color = "#27ae60"
                plugin_dir = os.path.dirname(os.path.abspath(__file__))
                icon_path = os.path.join(plugin_dir, 'wyrewyre.png')
                icon_url = icon_path
            elif db_group.lower() == "fiberklaar":
                header_color = "#2980b9"
                plugin_dir = os.path.dirname(os.path.abspath(__file__))
                icon_path = os.path.join(plugin_dir, 'fiberfiber.png')
                icon_url = icon_path
            elif db_group.lower() == "proximus":
                header_color = "#8e44ad"  # Example: purple
                plugin_dir = os.path.dirname(os.path.abspath(__file__))
                icon_path = os.path.join(plugin_dir, 'proximus (1).png')
                icon_url = icon_path
            else:
                header_color = "#2c3e50"
                icon_url = ""

            # Include image next to the title if available
            img_tag = f"<img src='{icon_url}' style='height:20px; width:40px; vertical-align:middle; margin-left:30px; border-radius:4px;' />" if icon_url else ""
            html += f"<h2 style='color:{header_color}; margin-top:20px; height:20px; width:40px;'>{img_tag}</h2>"
            text += f"{db_group.upper()}:\n{'=' * (len(db_group) + 1)}\n"

            # ACCESSPOINTS
            if "accesspoint" in type_dict:
                h, t = cls.summarize_accesspoints(type_dict["accesspoint"])
                html += f"<h3 style='text-decoration: underline; margin-left:5px'>⛘  Accespoints materiaal</h3>{h}"
                text += f"Accespoints materiaal:\n{t}\n"

            # CROSSINGS
            if "crossing" in type_dict:
                h, t = cls.summarize_crossings(type_dict["crossing"], f"{db_group} - Crossing")
                html += f"<h3 style='text-decoration: underline; margin-left:5px'>&#x26D9;   Crossings</h3>"
                html += f"<div style='margin-left:10px;'><b> Total Crossing Length:</b> {round(cls.accumulate_length(type_dict['crossing'], cls.CROSSING_PREFIXES)[2], 2)} m</div>"
                html += h
                text += f"Total Crossing Length : {round(cls.accumulate_length(type_dict['crossing'], cls.CROSSING_PREFIXES)[2], 2)} " + "\n"
                text += f"Crossings:\n{t}\n"


            # TRENCHING
            if "trenching" in type_dict:
                h, t = cls.summarize_trenching(type_dict["trenching"], f"{db_group} - Trenching")
                html += f"<h3 style='text-decoration: underline; margin-left:5px'>☵  Trenching</h3>"
                html += f"<div style='margin-left:10px;'><b> Total Trenching Length:</b> {round(cls.accumulate_length(type_dict['trenching'], cls.TRENCHING_PREFIXES)[2], 2)}m</div>"
                html += h
                text += f"Total Trenching Length : {round(cls.accumulate_length(type_dict['trenching'], cls.TRENCHING_PREFIXES)[2], 2)} \n"
                text += f"Trenching:\n{t}\n"

            html += "<hr>"
            text += "_" * 40 + "\n"

        return html, text, grouped_by_db

class AsbuiltInspectorDialog(QgsMapToolEmitPoint):
    def __init__(self, iface, parent=None):
        super().__init__(iface.mapCanvas())
        self.parent = parent
        self.canvas = iface.mapCanvas()
        self.iface = iface
        self.browser = None
        self.html_img_tag = None


        self.canvas = iface.mapCanvas()
        self.rubberBand = QgsRubberBand(self.canvas, QgsWkbTypes.PolygonGeometry)
        self.rubberBand.setColor(QColor(255, 0, 0, 100))
        self.rubberBand.setWidth(2)
        self.points = []
        self.found = []

        self.iface.messageBar().pushMessage(f" &#128433; Use your left mouse-button to start drawing a polygon <br> 🇫🇷 Utilisez le bouton gauche de la souris pour commencer à dessiner un polygone",
                                        level=Qgis.Info)

    def canvasPressEvent(self, event):
        if event.button() == Qt.LeftButton:
            point = self.canvas.getCoordinateTransform().toMapCoordinates(event.pos())
            self.points.append(point)
            self.rubberBand.addPoint(point, True)
        elif event.button() == Qt.RightButton:
            self.finish()

    def finish(self):
        if len(self.points) < 3:
            self.reset()
            return

        self.rubberBand.addPoint(self.points[0], True)
        # // add first point in self.points as star
        # // set full geom to use points arr
        self.rubberBand.setToGeometry(QgsGeometry.fromPolygonXY([self.points]))
        polygon_geom = QgsGeometry.fromPolygonXY([self.points])

        # Identify features
        found = self.identifyFeatures(polygon_geom)
        self.show_feature_dialog(found, polygon_geom)


        self.reset()
        return found

    def identifyFeatures(self, geometry):
        found_features = []
        for layer in QgsProject.instance().mapLayers().values():
            if not isinstance(layer, QgsVectorLayer):
                continue
            if layer.geometryType() == QgsWkbTypes.NoGeometry:
                continue

            # Optional: deselect all first
            layer.removeSelection()

            selected_ids = []
            request = QgsFeatureRequest().setFilterRect(geometry.boundingBox())
            for feature in layer.getFeatures(request):
                if geometry.intersects(feature.geometry()):
                    found_features.append((layer.name(), feature.id(), feature, layer))
                    selected_ids.append(feature.id())

            # Highlight (select) the features
            if selected_ids:
                layer.selectByIds(selected_ids)

        return found_features

    def save_text_browser_as_png(self):
        # Grab the widget as a pixmap
        pixmap = self.browser.grab()
        # Optional: Save to a file
        temp_file = tempfile.NamedTemporaryFile(suffix=".png", delete=False)
        pixmap.save(temp_file.name, "PNG")

        print(f"Saved to: {temp_file.name}")

        clipboard = QApplication.clipboard()
        clipboard.setPixmap(pixmap)



    def reset(self):
        self.points = []
        self.rubberBand.reset(QgsWkbTypes.PolygonGeometry)


    def copy_text(txt):
        QApplication.clipboard().setText(txt)

    def show_feature_dialog(self, found, geom):
        if not found:
            return

        dialog = QDialog(self.parent)
        dialog.setWindowTitle("SABINE")
        dialog.resize(300, 600)
        dialog.setSizeGripEnabled(True)
        layout = QVBoxLayout(dialog)

        self.browser = QTextBrowser(dialog)
        self.browser.setTextInteractionFlags(Qt.TextSelectableByKeyboard | Qt.TextSelectableByMouse)
        layout.addWidget(self.browser)

        # Generate summary HTML and plain text using helper class
        summarizer = FeatureSummarizer()
        html, plain_text, grouped = summarizer.generate_summary(found)

        self.browser.setHtml(html)


        self.copy_button = QPushButton("Copy Text", dialog)
        self.copy_button.setCursor(Qt.PointingHandCursor)

        plugin_dir = os.path.dirname(os.path.abspath(__file__))
        icon_pathp = os.path.join(plugin_dir, 'paste.png')
        icon_path = os.path.join(plugin_dir, 'water-color.png')
        icon = QIcon(icon_path)
        dialog.setWindowIcon(icon)
        iconc = QIcon(icon_pathp)
        self.copy_button.setIcon(iconc)

        layout.addWidget(self.copy_button)
        dialog.setLayout(layout)


        def copy_text():
            QApplication.clipboard().setText(plain_text)

        self.copy_button.clicked.connect(copy_text)

        dialog.exec_()

    def get_base_table_name(self, layer):
        uri = layer.dataProvider().dataSourceUri()

        # Extract dbname
        db_match = re.search(r"dbname='([^']+)'", uri)
        dbname = db_match.group(1).lower()

        # Extract table name (support multiple URI formats)
        table_match = re.search(r'table="[^"]+"\."([^"]+)"', uri)
        if not table_match:
            table_match = re.search(r'table="([^"]+)"', uri)
        if not table_match:
            table_match = re.search(r'table=([^ ]+)', uri)
        table_name = table_match.group(1).lower() if table_match else "other"

        return dbname, table_name





